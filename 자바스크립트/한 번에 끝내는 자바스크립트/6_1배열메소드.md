## for each
![](https://i.imgur.com/tLoxSX9.png)
> `forEach()` 에 들어가는 콜백 함수에  value, index, 전체 배열이 파라미터에  들어간다.

```js
let arr = [1, 2, 3, 4, 5];

arr.forEach((elm, num, array) => {
    console.log(`${num} 번째 배열의 value는 ${elm} 입니다.`);
    console.log(`전체 배열은 ${array}`);
})


전체 배열은 1,2,3,4,5
1 번째 배열의 value는 2 입니다.
전체 배열은 1,2,3,4,5
2 번째 배열의 value는 3 입니다.
전체 배열은 1,2,3,4,5
3 번째 배열의 value는 4 입니다.
전체 배열은 1,2,3,4,5
4 번째 배열의 value는 5 입니다.
전체 배열은 1,2,3,4,5
```

이렇듯 for문을 대체해서 사용할 수 있고, 콜백함수의 여러 매개변수를 통해 다양한 기능을 할 수 있다.

## map
![](https://i.imgur.com/rcwa7xp.png)
> `map()`도 마찬가지로 콜백함수 파라미터에 위의 값들이 들어간다.

```js
let arr = [1, 2, 3, 4, 5];
let newArray = [];
newArray = arr.map((value, index, oriArr) => {
    console.log(`${index} 번째 에 있는 값은 ${value}`)
    return value * 10;
})

console.log(newArray);

0 번째 에 있는 값은 1
1 번째 에 있는 값은 2
2 번째 에 있는 값은 3
3 번째 에 있는 값은 4
4 번째 에 있는 값은 5
[ 10, 20, 30, 40, 50 ]
```

map 내장함수는 호출한 결과를 모아서 새로운 배열로 반환해주는 것으로, 배열의 모든 요소에 연산을 적용하고, 그 결과를 새로운 배열로 반환

map의 동작성에 대해 조금 더 디테일하게 보자
위의 코드에서 map 도중에 newArray를 console로 보면 아무것도 없는데,
map은 동작 중에 임시배열 만들어 동작을 완료하고 그 임시배열을 결과로서 반환하기 때문이다.

```js
Array.prototype.map = function (callback) {
    let result = []; // 새로운 임시 배열을 만듬
    for (let i = 0; i < this.length; i++) {
        // 배열의 길이만큼 반복하기 this.length는 원본 배열의 길이
        const returnValue = callback(this[i], i, this);
        console.log(`${i}번째 콜백 결과 :`, returnValue);
        result.push(returnValue);
        console.log(`map 동작 중 result : ${result}`)
        //원본 배열 this의 i번째 값을 꺼내서 callback 함수에 전달(value, index, array)형태로
        // 그 결과를 result에 push한다.
    }
    return result;
};
  
let arr = [1, 2, 3];
let testArr = arr.map((v, n, a) => {
    console.log("콜백 실행 중 :", v, n, a);
    return v * 3;
})
console.log(testArr);

콜백 실행 중 : 1 0 [ 1, 2, 3 ]
0번째 콜백 결과 : 3
map 동작 중 result : 3
콜백 실행 중 : 2 1 [ 1, 2, 3 ]
1번째 콜백 결과 : 6
map 동작 중 result : 3,6
콜백 실행 중 : 3 2 [ 1, 2, 3 ]
2번째 콜백 결과 : 9
map 동작 중 result : 3,6,9
[ 3, 6, 9 ]
```

위에는 prototype으로 map을 정의해서 console로 찍으며 본 값이다.

결론적으로 `map()` 은 원본 함수를 해치지 않고, 변화된 값을 임시 배열을 이용하여 콜백함수에 파라미터로 value, index, 원본 array를 주며 새로운 배열을 반환해준다.

## at
> 배열의 특정 요소를 찾는 함수

`arr.at(0)` : arr에서 0번째 배열의 value값 출력
`arr.at(-1)` : arr에서 마지막 배열의 value값 출력

## includes
> 매겨변수로 받은 요소를 배열이 포함하고 있는가?

![](https://i.imgur.com/xF683ES.png)


```js
let arr = ['blue', 'green', 'red'];
console.log(arr.includes('red')); // true
console.log(arr.includes('purple')); // false
console.log(arr.includes('blue')); // true
console.log(arr.includes('blue',1)); // false
```

두 번쨰 인자는 시작 index 번호로, 생략되면 0부터 시작한다.

## indexOf
> 특정 값이 배열 요소에 있는지를 검사하는 것이 아닌, 특정 값을 지닌 요소가 몇 번째 index에 위치하는 요소인지 찾아주는 함수

![](https://i.imgur.com/gxtSVUo.png)

```js
let arr = ['blue', 'green', 'red'];
console.log(arr.indexOf('blue'));
console.log(arr.indexOf('blue', 1));
0
-1
```

blue가 0번 index에 있어서 0을 출력하였고, blue를 1번 index부터 찾으니 없으니 -1을 출력하였ㄷ.

## findIndex
> indexOf는 배열의 몇 번째 index인지를 찾아주지만, 배열의 형태가 객체형태 혹은 배열 형태이면 index를 찾지 못한다.

