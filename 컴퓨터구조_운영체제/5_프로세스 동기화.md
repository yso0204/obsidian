# 동기화란?
> 프로세스들 사이의 수행 시기를 맞추는 것을 의미한다.

- 실행 순서 제어 : 프로세르를 올바른 순서대로 실행
- 상호 배제 : 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기
## 공유 자원과 임계 구역
### 공유 자원
> 두 개 이상의 프로세스들이 참고하여 사용하는 자원으로 전역 변수, 파일, 입출력장치 등이 될 수 있다.

### 임계 구역
> 공유 자원 중 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원으로 여러 프로세스가 접근하면 한 번에 하나의 프로세스만 접근 할 수 있도록 제어해야한다.

여러 프로세스가 접근하여 문제가 생긴 것을 레이스 컨디션(race condition)이라고 한다.

이러한 문제는 고급언어를 저급언어로 변환하는 과정에서 이뤄지는데
```
total ++

r1 = total;
r1 = r1+1;
total = r1;
```

```
total --

r2 = total;
r2 = r2-1;
total = r2;
```

이 두 코드가 실행되며 중간에 context switching이 이뤄질 수 있는데, 이 과정에서 중간에 문제가 발생하여 total 값이 섞여 계산될 수 있다.

이때 두 개 이상의 프로세스가 임계 구역에 동시에 접근할 수 없도록 관리하는 것을 상호 배제(mutual exclusion)이라고 한다.

OS는 임계 구역 문제를 해결하고자 아래 세 가지 원칙을 따른다.

- 상호 배제(mutual exclusion) : 한 프로세스가 임계 구역에 들어왔다면, 다른 프로세스가 접근할 수 없다.
- 진행(progress) :  임계구역에 어떤 프로세스도 없다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- 유한 대기(bounded waiting) : 한 프로세스가 임계 구역에 진입하고 싶다면, 그 프로세스는 언제가는 들어올 수 있어야한다. (무한대기 X)

# 동기화 기법
## 뮤텍스 락
> 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 하는 도구, 즉 상호 배제를 위한 동기화 도구 이다.

마치 탈의실에 '이용 중' 표시를 하여 한 사람만 사용 가능하도록 한 것과 동일

단순한 형태는 전역 변수 하나, 함수 두개로 구현 가능

- 자물쇠 : 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제 : release 함수

### acquire
프로세스가 임계 구역에 진입하기 전에 호출하는 함수
만일, 임계 구역이 잠겨있다면 열릴 때 까지 임계 구역을 반복적으로 확인하고, 열려있다면 lock을 true로 변경

### release
임계 구역에서의 작업이 끝나고 호출하는 함수
lock을 false 로 바꿈

```
acquire()
임계구역
release()
```
acquire()에서는
```
while(lock==true)
임게 구역이 잠겨 있는지를 반복적으로 확인 busy waiting
lock=true;
```

release() 는
```
작업 완료 후
lock =false;
```
이렇게 하면 위에서 문제가 된, 동시에 여러 프로세스들이 동시에 접근하는 race condition을 해소할 수 있다.

프로세스는
- 락을 획득할 수 없다면, 무작정 기다리고
- 락을 획들할 수 있다면, lock을 true로 변환 후 임계 구역을 잠그고
- 임계 구역을 빠져나오면서 lock을 false로 바꾸고 임계 구역을 푼다.
acqure에서 계속해서 임계구역이 잠겨있는지 체크하는데, 이런 대기를 바쁜대기(busy wait)라고 한다.

- 사실 위의 방식은 간단하게 예시를 든 것으로 허술한 부분이 많음

## 세마포(semaphore)
> 뮤텍스 락과 비슷하지만, 일반화된 동기화 방식
> 하나의 락이 아닌, 여러개의 공유 자원이 있을 때 사용

세마포는 철도 신호기에서 유래되었는데, 철도 신호와 마찬가지로 '멈춤' 신호와 '출발' 신호로 임계 구역을 관린한다.

- 임계 구역에 진입 할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수) : 전역 변수 S
- 임계 구역에 진입 해도 되는지, 기다려야 할지를 알려주는 wait 함수
- 임계 구역 앞에서 기다리는 프로세스에 신호를 주는 siganal 함수

```
wait()
임계구역
signal()
```
### wait & signal
```
wait(){
	while(S<=0)
	;
	S--;
}

signal(){
	S++;
}
```

이렇게 구성하고 프로세스가 3개, 공유자원이 2개인 경우
1. P1 은 wait 호출, S를 1 감소 후 임계 구역 진입
2. P2 은 wait 호출, S를 1 감소 후 임계 구역 진입 (S=0)
3. P3 은 wait 호출 , S가 0 이므로 무한히 반복하며 S확인
4. ....

이렇게 진행될 텐데, 이러면 P3는 무한히 대기하면서  CPU 자원을 사용하게 된다. 
이를 위해 해당 프로세스 상태를 대기 상태로 바꾸고 프로세스의 [[3_0_프로세스와 스레드#프로세스 제어 블록|PCB]]를 세마포를 위한 대기 큐에 집어 넣는다.

```
wait(){
	S--;
	if(S<0){
		add this process to Queue;
		sleep();
	}
}

signal(){
	S++;
	if(S<=0){
		remove a procesee p from Queue
		wakeup(p)
	}
}
```

이러면 위에서 P3가 wait()를 호출하면서 S가 -1 이되고 대기 상태에서 대기큐에 들어가고, P1이 signal()을 호출하면서 S가 0 이되어 큐에서 제거 되며 준비 큐로 이동되어 실행된다.

## 모니터
> 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어서 관리한다.
> 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근한다.

락(Mutex) + 조건 변수(Condition Variable)이 결합된 형태
- 임계 구역을 자동으로 보호
- 락/언락을 직접 하지 않고 `monitor`안의 함수에 들어갈 때 자동으로 락이 걸리고, 나올 때 자동으로 풀림

### 프로세스 큐
공유 자원을 쓰기 위해 monitor 진입을 기다리는 프로세스

### 조건 변수 큐
wait()를 호출한 프로세스들이 조건 충족이 될 때 까지 대기

### 프로세스 요약 및 실행 흐름
- 프로세스가 moniotor 함수 호출 > 자동으로 락 > 실행 후 자동 해체
![](https://i.imgur.com/rFyXW1i.png)

