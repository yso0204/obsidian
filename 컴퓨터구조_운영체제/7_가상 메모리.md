# 연속 메모리 할당
> 프로세스에 연속적인 메모리 공간을 할당하는 방식
![](https://i.imgur.com/9YK3Sgo.png)

## 스와핑
메모리에 한번 올라간 프로세스는 영원히 적재되어있는 것이 아니다. 대기 상태로 전환되었거나, 오랫동안 사용되지 않은 프로세스 등 들은 임시로 보조기억장치의 일부로 옮기고, 그렇게 생긴 빈공간에 또 다른 프로세스를 적재하여 실행하는 방식을 **스와핑** 이라고 한다.

이때 사용된 보조기억장치 일부 영역을 **스왑 영역(swap space)** 이라고 한다. 
옮겨지는 것은 **스왑 아웃(swap out)** , 반대로 메모리로 옮겨오는 것은 **스왑 인(swap in)** 이라고 한다.

![](https://i.imgur.com/tqmwuLf.png)

이러한 스와핑을 이용하면, 프로세스가 용구하는 메모리 크키가 실제 메모리 크기 보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.

### 스와핑의 장점
> 메모리 공간이 부족할 때 가상 메모리 공간을 제공해 프로그램이 실행될 수 있게 해준다.
> 스와핑을 통해 사용되지 않는 메모리 공간을 보조기억장치로 옮겨, 데이터나, 프로그램을 위한 공간을 확보해 효율성이 증가한다.

### 스와핑의 단점
> 보조기억장치의 접근 속도는 메모리보다 느리기에 시스템의 성능 저하를 불러올 수 있다.

## 메모리 할당(memory allocation)
> 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식으로는
> 최초 적합 / 최적 적합 / 최악 적합 등이 있다.

### 최초 적합(first fit)
> OS가 메모리 내의 빈 공간을 순서대로 검색하다가, 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식

- 프로세스가 적대될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식으로 검색을 최소화할 수 있고, 빠른 할당이 가능
### 최적 적합(best fit)
> OS 가 메모리의 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치

- 프로세스가 적재될 수 있는 가장 작은 공간을 찾고 배치하므로 효율적인 메모리 활용
### 최악 적합(worst fit)
> OS가 빈 공간을 모두 검색한 후 최적 적합과는 반대로 가장 큰 공간에 프로세스를 배치


## 외부 단편화

이렇듯 메모리에 프로세스들을 연속적으로 배치하는 것은 당연하게 느껴질 수 있으나, 실제로 효율적인 활용 방식은 아니다. 
연속 메모리 할당은 **외부 단편화(external fragmentation)** 이라는 문제를 내포하고 있기 때문이다.

![](https://i.imgur.com/vspzZBw.png)

예를 들어 위 그림처럼, 프로스세 2개가 종료되어 메모리에 사용가능한 공간은 30MB 이지만, 연속되어 있지 않기 때문에 30MB의 프로세스를 적재할 수 없다. 
이는 스와핑에서도 동일하게 발생하는 문제이다.

분명히 빈 공간이지만, 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고 이는 결국 메모리 낭비로 이어진다. 이러한 현상을 **외부 단편화(external fragmentation)** 이라고 한다.

이러한 현상을 막기 위해서 **압축(compaction)** 하는 방법이 있다.
예를 들어, 위에 P2 프로세스를 압축하여 앞 주소의 10MB쪽으로 옮겨 30MB를 연속적인 공간으로 만드는 것인데, 이러한 행위를 위해 시스템은 하던일을 중지하고 메모리에 있는 내용을 옮기는 작업을 해야하는데 이는 많은 오버헤드를 야기하고, 어떻게해야 오버헤드를 최소화 해야하는지에 대한 명확한 기준도 없다.

| **항목**     | **오버헤드 내용**                         |
| ---------- | ----------------------------------- |
| 시간 오버헤드    | 프로세스들을 옮기는 데 걸리는 **시간 지연**          |
| CPU 오버헤드   | 데이터를 이동하고 주소 재계산하는 **CPU 연산**       |
| 메모리 오버헤드   | 이동 중 임시 공간 확보에 드는 **메모리 사용량 증가**    |
| 실행 중단 오버헤드 | 현재 실행 중인 프로세스를 멈추고 옮겨야 하는 **일시 정지** |

결국 이를 위해 등장한 것이 가상 메모리 기법, 그 중에서도 페이징 기법이다.

# 페이징을 통한 가상 메모리 관리

**가상메모리(virtual memomry)** 는 실행하고자 하는 프로그램의 일부만 메모리에 적재하여, 실제 메모리 공간보다 더 큰 프로세스를 실행할 수 있게 하는 기술
## 페이징 이란?

앞에서 발생한 연속 메모리 할당의 외부 단편화는 결국 각 프로세스들의 크기가 그대로 메모리에 할당되어 생긴 문제이다.

만약, 메모리와 프로세스를 일정한 단위로 자르고, 메모리에 불연속적으로 할당할 수 있다면 앞서 발생한 외부 단편화를 막을 수 있다.

이것을 **페이징(paging)** 이라고 한다. 
프로세스의 논리 주소 공간을 **페이지(page)** 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임(frame)** 이라는 
