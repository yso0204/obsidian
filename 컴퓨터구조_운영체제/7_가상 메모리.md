# 연속 메모리 할당
> 프로세스에 연속적인 메모리 공간을 할당하는 방식
![](https://i.imgur.com/9YK3Sgo.png)

## 스와핑
메모리에 한번 올라간 프로세스는 영원히 적재되어있는 것이 아니다. 대기 상태로 전환되었거나, 오랫동안 사용되지 않은 프로세스 등 들은 임시로 보조기억장치의 일부로 옮기고, 그렇게 생긴 빈공간에 또 다른 프로세스를 적재하여 실행하는 방식을 **스와핑** 이라고 한다.

이때 사용된 보조기억장치 일부 영역을 **스왑 영역(swap space)** 이라고 한다. 
옮겨지는 것은 **스왑 아웃(swap out)** , 반대로 메모리로 옮겨오는 것은 **스왑 인(swap in)** 이라고 한다.

![](https://i.imgur.com/tqmwuLf.png)

이러한 스와핑을 이용하면, 프로세스가 용구하는 메모리 크키가 실제 메모리 크기 보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.

### 스와핑의 장점
> 메모리 공간이 부족할 때 가상 메모리 공간을 제공해 프로그램이 실행될 수 있게 해준다.
> 스와핑을 통해 사용되지 않는 메모리 공간을 보조기억장치로 옮겨, 데이터나, 프로그램을 위한 공간을 확보해 효율성이 증가한다.

### 스와핑의 단점
> 보조기억장치의 접근 속도는 메모리보다 느리기에 시스템의 성능 저하를 불러올 수 있다.

## 메모리 할당(memory allocation)
> 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식으로는
> 최초 적합 / 최적 적합 / 최악 적합 등이 있다.

### 최초 적합(first fit)
> OS가 메모리 내의 빈 공간을 순서대로 검색하다가, 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식

- 프로세스가 적대될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식으로 검색을 최소화할 수 있고, 빠른 할당이 가능
### 최적 적합(best fit)
> OS 가 메모리의 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치

- 프로세스가 적재될 수 있는 가장 작은 공간을 찾고 배치하므로 효율적인 메모리 활용
### 최악 적합(worst fit)
> OS가 빈 공간을 모두 검색한 후 최적 적합과는 반대로 가장 큰 공간에 프로세스를 배치


## 외부 단편화

이렇듯 메모리에 프로세스들을 연속적으로 배치하는 것은 당연하게 느껴질 수 있으나, 실제로 효율적인 활용 방식은 아니다. 
연속 메모리 할당은 **외부 단편화(external fragmentation)** 이라는 문제를 내포하고 있기 때문이다.

![](https://i.imgur.com/vspzZBw.png)

예를 들어 위 그림처럼, 프로스세 2개가 종료되어 메모리에 사용가능한 공간은 30MB 이지만, 연속되어 있지 않기 때문에 30MB의 프로세스를 적재할 수 없다. 
이는 스와핑에서도 동일하게 발생하는 문제이다.

분명히 빈 공간이지만, 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고 이는 결국 메모리 낭비로 이어진다. 이러한 현상을 **외부 단편화(external fragmentation)** 이라고 한다.

이러한 현상을 막기 위해서 **압축(compaction)** 하는 방법이 있다.
예를 들어, 위에 P2 프로세스를 압축하여 앞 주소의 10MB쪽으로 옮겨 30MB를 연속적인 공간으로 만드는 것인데, 이러한 행위를 위해 시스템은 하던일을 중지하고 메모리에 있는 내용을 옮기는 작업을 해야하는데 이는 많은 오버헤드를 야기하고, 어떻게해야 오버헤드를 최소화 해야하는지에 대한 명확한 기준도 없다.

| **항목**     | **오버헤드 내용**                         |
| ---------- | ----------------------------------- |
| 시간 오버헤드    | 프로세스들을 옮기는 데 걸리는 **시간 지연**          |
| CPU 오버헤드   | 데이터를 이동하고 주소 재계산하는 **CPU 연산**       |
| 메모리 오버헤드   | 이동 중 임시 공간 확보에 드는 **메모리 사용량 증가**    |
| 실행 중단 오버헤드 | 현재 실행 중인 프로세스를 멈추고 옮겨야 하는 **일시 정지** |

결국 이를 위해 등장한 것이 가상 메모리 기법, 그 중에서도 페이징 기법이다.

# 페이징을 통한 가상 메모리 관리

**가상메모리(virtual memomry)** 는 실행하고자 하는 프로그램의 일부만 메모리에 적재하여, 실제 메모리 공간보다 더 큰 프로세스를 실행할 수 있게 하는 기술
## 페이징 이란?

앞에서 발생한 연속 메모리 할당의 외부 단편화는 결국 각 프로세스들의 크기가 그대로 메모리에 할당되어 생긴 문제이다.

만약, 메모리와 프로세스를 일정한 단위로 자르고, 메모리에 불연속적으로 할당할 수 있다면 앞서 발생한 외부 단편화를 막을 수 있다.

이것을 **페이징(paging)** 이라고 한다. 
프로세스의 **논리 주소 공간**을 **페이지(page)** 라는 일정한 단위로 자르고, 
메모리 **물리 주소 공간**을 **프레임(frame)** 이라는 페이지와 동일한 크기의 일정한 단위로 잘라 
할당하는 가상 메모리 관리 기법이다.

![](https://i.imgur.com/nHpIFXB.png)


마찬가지로 페이징에서도 스와핑을 할 수 있다. 다만, 단위가 프로세스가 아닌 페이지 단위로 스왑 아웃/인 되는 차이가 있다. 
페이징 시스템에서는 **페이지 아웃 / 페이지 인** 이라고 부르기도 한다.

![](https://i.imgur.com/UNXhBy7.png)

이는 프로세스를 실행하기 위해 그 프로세스 전체를 메모리에 적재할 필요없이, 필요한 페이지 일부만 메모리의 프레임에 올려 실행할 수 있다는 의미로, 메모리보다 더 큰 프로세스를 실행할 수 있게 해준다.

## 페이지 테이블
> 앞서 본 페이징 기법을 이용하면, 메모리에 프로세스의 페이지가 불연속적으로 적재되어 있다.
> 이를 위해 페이징 기법은 프로세스가 실제 메모리의 물리 주소에 불연속적으로 배치되더라도 CPU가 바라보는 논리 주소에는 연속적으로 배치되도록 **페이지 테이블(page table)** 을 이용한다.

![](https://i.imgur.com/0FjlytF.png)

이렇게 되면 CPU는 메모리에 프로세스들이 분산되어 저장되어 있더라도, 논리 주소를 순차적으로 실행하면 된다.

> [! memo]
> 페이징은 외부 단편화 문제를 해결할 수 는 있으나, 내부 단편화(internal fragmentation)을 야기할 수 있다.
> 예를 들어 모든 프로세스가 지정된 페이지 크기로 잘리는 것이 아니라서, 마지막에 페이지 크기보다 작은 페이지가 생성된다

프로세스마다 각자의 프로세스 테이블을 가지고 있고, 각 프로세스들의 페이지 테이블은 메모리에 적재되어 있다.
그리고 CPU내의 **페이지 테이블 베이스 레지스터(Page Table Base Register)** PTBR는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

하지만, 메모리에 페이지 테이블이 있다는 의미는 CPU가 메모리에 있는 페이지 테이블을 보기 위해 1 번, 이를 통해 알게된 프레임에 접근하기 위해 1 번, 총 **2 번** 접근이 필요하다.

이를 해결하기 위해서 CPU 곁에 **TLB(Translation Lockaside Buffer)** 라는 페이지 테이블 캐시 메모리를 둔다. TLB는 페이지 테이블의 일부 내용을 저장한다.(주로 최근에 사용된 페이지 위주)

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB hit** 라고 한다. 이 경우 CPU는 메모리에 접근을 한번만 하면된다.
반대로 없을 경우는 **TLB miss** 라고 하며, 이 경우에는 메모리에 2번의 접근이 필요하다.

## 페이징에서의 주소 변환

특정 주소에 접근하려면 두 가지 정보가 필요한다.
- 접근하고자 하는 페이지 / 프레임
- 접근하려는 주소가 페이지 / 프레임 에서 얼마나 떨어져 있는가?

그렇기에 논리주소는 **페이지 번호(page number)** 와 **변위(offset)** 으로 이루어져 있다.
만약 CPU가 32비트 주소를 내보낸다면 N비트는 페이지 번호, 32-N 비트는 변위 이런식으로 이루어져 있다.
![](https://i.imgur.com/Q8TixUF.png)

예를 들어 아래와 같은 페이지 테이블과 메모리 상태라면
![](https://i.imgur.com/hN5mNkZ.png)

CPU가 5번 페이지, 변위 2라는 곳에 접근한다면?
실제 물리 주소 공간에서 CPU가 접근하는 곳은 10번지 이다.

## 페이지 테이블 엔트리
> 페이지 테이블의 각각의 행동들을 **페이지 테이블 엔트리(Page Table Entry)PTE** 라고 한다.

PTE에 담기는 정보는 페이지 번호, 프레임 번호 말고도 여러가지 정보들이 있다.
- 유효비트
- 보호비트
- 참조비트
- 수정비트
- ....

### 유효 비트(valid bit)
> 현재 페이지에 접근이 가능한가?

페이징에서도 스와핑이 가능하고 이는 프로세스 전체가 메모리에 적재되어 있는 것이 아닌, 일부만 메모리에 적재되어 있는 것이 가능하다.
즉, 유효 비트는 현재 페이지가 메모리에 적재되어 있는가? 를 나타낸다.

만약 유효 비트 0 인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 **페이지 폴트(page fault)** 라는 예외가 발생한다.
CPU 가 페이지 폴트를 처리하는 과정은 HW 인터럽트를 처리하는 과정과 유사하다.
1. CPU는 기존의 작업내용을 백업
2. 페이지 폴트 처리 루틴을 실행
3. 2번의 루틴은 페이지를 메모리에 적재하고 유효비트는 1로 변경
4. 이후 CPU는 해당 페이지에 접근이 가능

### 보호 비트(protection bit)
> page 보호를 위해 존재하는 비트

- 읽기(Read) r
- 쓰기(Write) w
- 실행(eXecute) x
이렇게 3가지 조합으로 해당 페이지 보호 비트를 이루고 있다.


### 참조 비트(reference bit)
> 해당 페이지에 CPU가 접근한 적이 있는지 여부를 나타낸다.

### 수정 비트(modified bit)
> 해당 페이지에 데이터를 쓴 적이 없는지 수정 여부를 알려준다.

**더티 비트(dirty bit)** 라고도 부르며 이러한 수정 비트가 필요한 이유는, 페이지가 메모리에서 사라질 때  보조기억장치 작업을 해야하는지 여부를 판단하기 위해 존재한다.

예를 들어, 메모리에 있는 페이지의 수정 비트가 0 이라면 보조기억장치에 저장된 해당 페이지의 내용과 동일하지만, 1 이라면 서로 다른 값을 가지기에 변경된 값을 보조기억장치에 기록하는 작업이 추가로 필요하다.

# 페이지 교체와 프레임 할당

## 요구 페이징
> 프로세스를 메모리에 적재할 때 모든 페이지를 적재하지 않고, 필요한 페이지만을 메모리에 적재하는 기법을
> **요구 페이징(demand paging)** 이라고 한다.

요구 페이징의 기본적인 양상을 아래와 같다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1) CPU는 페이지가 적재된 프레임에 접근
3. 유효 비트가 0 인경우 페이지 폴트 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재하고 유효 비트는 1로 변경
5. 다시 1번을 수행

만약 아무런 페이지도 메모리에 적재되어 있지않다면, 1번부터 페이지 폴트가 발생할 것이고, 실행에 필요한 페이지가 어느 정도 적재된 이후 부터는 빈도가 떨어질 것이다.

이를 **순수 요구 페이징(pure demand paging)** 이라고 한다.

이러한 요구 페이징 시스템이 안정적으로 작동하기 위해서는 아래 두 가지를 해결해야한다.
1. 페이지 교체
2. 프레임 할당

요구 페이징 기법으로 메모리에 페이지를 적재하다 보면 언젠가 메모리가 가득차게 되는데, 어떤 페이지를 보조기억장치로 내보내야하는가? 
이를 결정하는 방법이 **페이지 교체 알고리즘** 이다.

## 페이지 교체 알고리즘
좋은 페이지 교체 알고리즘은 결국 페이지 폴트를 가장 적게 일으키키는 알고리즘이다.

이를 위해 **페이지 퐅트 횟수** 를 알 수 있어야하고, 이는 **페이지 참고열(page reference string)** 을 통해 알 수 있다.

만약 CPU가 