# CPU 스케줄링 개요
> 운영체제가 process 들에게 합리적으로 CPU 작원을 배분하는 것을 CPU 스케줄링이라고 한다

### 프로세스 우선순위
> 프로세스마다 우선순위가 다른데, 대표적으로 입출력 작업이 많은 프로세스가 있다

프로세스마다 CPU 혹은 입출력 장치를 주로 사용하는 종류가 나뉜다
- 입출력 집중 프로세스(I/O bound process)
- CPU 집중 프로세스(CPU bound process)

#### CPU burst, I/O burst
> CPU를 이용하는 작업을 CPU burst 라고 하며
> I/O를 이용하는 작업을 I/O burst 라고 한다

이렇듯 프로세스마다 입출력을 , CPU를 써야하는 프로세스들로 나뉘는데 CPU를 차례대로 돌아가며 사용하는 것보다 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적이다.

이를 위해 OS 는 process  마다 중요도인 우선순위(priority) 를 배분한다.

### 스케줄링 큐
> PCB 에 우선순위가 적혀있긴 하지만, CPU가 사용할 다음 프로세스를 찾기위해 OS가 매번 모든 프로세스의 PCB를 뒤져가며 우선 순위를 보는 것은 비효율적이다

이를 위해 프로세스들을 줄을 세우는데, 이를 스케줄링 큐 라고 부른다

 ![](https://i.imgur.com/Qs1i5Uz.png)

OS가 관리하는 대부분의 자원은 큐로 관리되며, 이를 위해 준비큐, 대기큐가 있다

- 준비 큐(ready queue) : CPU를 사용하고 싶은 프로세스들이 서는 큐
- 대기 큐(waiting queue) : 입출력 장치를 이용하기 위해 대기 상태로 접어든 프로세드릉이 서는 큐 
### 선점형과 비선점형 스케줄링
- 선점형 : 어떤 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 OS가 프로세스로부터 자원을 강제로 뻇어 다른 프로세스에 할당할 수 있는 스케줄링
	- 한 프로세스의 독점을 막고, 골고루 자원을 배분할 수 있으나, context switching 과정에서 overhead가 발생 할 수 있다
- 비선점형 : 하나의 프로세스가 현재 자원을 사용 중이라면, 사용중인 프로세스가 대기 상태 혹은 종료되기 전까지는 다른 프로세스가 끼어들 수 었는 스케줄링
	- context swtiching 이 적지만, 독점이 발생할 수 있다.

## CPU 스케줄링 알고리즘
> 다양한 알고리즘이 있지만, 어떤게 있나 대충 훝어가는 느낌으로

### 선입 선처리 스케줄링(FCFS)
> 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링

![](https://i.imgur.com/2sYApNi.png)

- 위에서 언급한대로, 비선점형이므로 앞선 프로세스가 자원 이용 시간이 길면 뒤에 대기중인 C 프로세스는 2ms를 사용하기 위해서 22ms를 기다리게 된다.
- 이런 현상을 호위 효과(convoy effect) 라고한다.
### 최단 작업 우선 스케줄링(SJF)
> 호위효과를 방지하기 위해 CPU 사용 시간이 짧은 프로세스부터 실행시킨다

### 라운드 로빈 스케줄링
> 선입선출(FIFO)에 타임 슬라이스 라는 개념을 더한 스케줄링
> 타임 슬라이스란 각 프로세스가 CPU를 이용할 수 있는 정해진 시간

즉 정해진 타임 슬라이스만큼의 시간 동안을 돌아가며 CPU를 이용하는 선점형 스케줄링

- 타임슬라이스 크기가 중요한데, 너무 크면 결국 호위효과가 발생할 가능성이 높고
- 너무 작으면, context switching 에 발생하는 비용이 크다

### 최소 잔여 시간 우선 스케줄링(SRT)
> 최단 작업 우선 스케줄링과 로빈 알고리즘을 합친 스케줄링

즉, 정해진 타임 슬라이스 만큼 자원을 사용하지만, 이후 사용할 프로세느는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨

### 우선순위 스케줄링(priority sheduling)
> 프로세스들에 우선순위를 부여하고 가장 높은 우선 순위를 가진 프로세스부터 실행하는 스케줄링

